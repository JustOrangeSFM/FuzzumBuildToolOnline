#pragma once
#define MINIAUDIO_IMPLEMENTATION
#include "miniaudio.h"

#include "ModuleManager/IModule.h"

#include <cstdint>
#include <mutex>
#include <vector>
#include <memory>
#include <algorithm>

#define AUDIO_MAX_CHANNELS 16
using AudioFlags = uint8_t;

// Define MA_SOUND_FLAG_LOOP since MiniAudio doesn't expose it publicly
#ifndef MA_SOUND_FLAG_LOOP
#define MA_SOUND_FLAG_LOOP 0x2
#endif

namespace Audio {

    static float g_masterVolume = 1.0f;
    static float g_channelVolumes[AUDIO_MAX_CHANNELS] = { 1.0f };

    static ma_engine g_engine;
    static bool g_engineInitialized = false;

    struct SoundEntry {
        int id;
        std::unique_ptr<ma_sound> sound;
    };

    static std::vector<SoundEntry> g_activeSounds;
    static std::mutex g_mutex;
    static int g_nextSoundId = 1;

    inline void InitializeEngine() {
        if (!g_engineInitialized) {
            ma_engine_init(nullptr, &g_engine);
            g_engineInitialized = true;
        }
    }

    inline void SetChannelVolume(int channel, float volume) {
        if (channel >= 0 && channel < AUDIO_MAX_CHANNELS) {
            g_channelVolumes[channel] = volume;
        }
    }

    inline void SetMasterVolume(float volume) {
        g_masterVolume = volume;
        ma_engine_set_volume(&g_engine, volume);
    }

    inline AudioFlags MakeFlags(int channel, bool applyMaster = true) {
        return (static_cast<uint8_t>(channel & 15) << 1) | (applyMaster ? 1 : 0);
    }

    inline int Play(const char* filepath, AudioFlags flags, bool loop = false, uint64_t startTimeMs = 0) {
        InitializeEngine();

        auto sound = std::make_unique<ma_sound>();

        ma_uint32 flagsMaSound = 0;
        if (loop) flagsMaSound |= MA_SOUND_FLAG_LOOP;

        ma_result result = ma_sound_init_from_file(&g_engine, filepath, flagsMaSound, nullptr, nullptr, sound.get());
        if (result != MA_SUCCESS) {
            return 0;  // failed to load
        }

        if (startTimeMs > 0) {
            ma_uint64 totalFrames = 0;
            ma_sound_get_length_in_pcm_frames(sound.get(), &totalFrames);
            ma_uint64 seekFrame = static_cast<ma_uint64>((startTimeMs / 1000.0) * ma_engine_get_sample_rate(&g_engine));
            if (seekFrame < totalFrames) {
                ma_sound_seek_to_pcm_frame(sound.get(), seekFrame);
            }
        }


        int channel = (flags >> 1) & 15;
        bool applyMaster = (flags & 1) != 0;
        float volume = (channel < AUDIO_MAX_CHANNELS) ? g_channelVolumes[channel] : 1.0f;
        if (applyMaster) volume *= g_masterVolume;
        ma_sound_set_volume(sound.get(), volume);

        ma_sound_start(sound.get());

        int soundId = 0;
        {
            std::lock_guard<std::mutex> lock(g_mutex);
            soundId = g_nextSoundId++;
            g_activeSounds.push_back({ soundId, std::move(sound) });
        }

        if (loop) {
            // Start a thread that monitors the sound state and restarts if finished
            std::thread([thisId = soundId]() {
                while (true) {
                    {
                        std::lock_guard<std::mutex> lock(g_mutex);
                        auto it = std::find_if(g_activeSounds.begin(), g_activeSounds.end(), [thisId](const SoundEntry& e) { return e.id == thisId; });
                        if (it == g_activeSounds.end()) {
                            break; // sound stopped or erased
                        }
                        if (!ma_sound_is_playing(it->sound.get())) {
                            ma_sound_start(it->sound.get());
                        }
                    }
                    std::this_thread::sleep_for(std::chrono::milliseconds(100));
                }
                }).detach();
        }
        return soundId;
    }


    inline void Stop(int soundId) {
        std::lock_guard<std::mutex> lock(g_mutex);
        auto it = std::find_if(g_activeSounds.begin(), g_activeSounds.end(),
            [soundId](const SoundEntry& e) { return e.id == soundId; });
        if (it != g_activeSounds.end()) {
            ma_sound_stop(it->sound.get());
            ma_sound_uninit(it->sound.get());
            g_activeSounds.erase(it);
        }
    }

    inline void StopAll() {
        std::lock_guard<std::mutex> lock(g_mutex);
        for (auto& e : g_activeSounds) {
            ma_sound_stop(e.sound.get());
            ma_sound_uninit(e.sound.get());
        }
        g_activeSounds.clear();
    }

    inline void Uninitialize() {
        StopAll();
        if (g_engineInitialized) {
            ma_engine_uninit(&g_engine);
            g_engineInitialized = false;
        }
    }

    // Pause/resume should be implemented manually if needed (not built-in).
}


/*#define MINIAUDIO_IMPLEMENTATION
#include "AudioSystem.h"
#include <iostream>
#include <thread>
#include <chrono>

int main() {
    Audio::SetMasterVolume(0.9f);
    for (int i = 0; i < 16; ++i) Audio::SetChannelVolume(i, 0.5f);

    std::cout << "Playing channel 0...\n";
    int soundID0 = Audio::Play("music.wav", Audio::MakeFlags(0, true));
    std::this_thread::sleep_for(std::chrono::seconds(3));
    Audio::StopAll();

    std::cout << "Playing channel 1 looped...\n";
    int soundID1 = Audio::Play("music.wav", Audio::MakeFlags(1, true), true);
    std::this_thread::sleep_for(std::chrono::seconds(10));
    Audio::StopAll();

    std::cout << "Playing from 10 sec on channel 2...\n";
    int soundID2 = Audio::Play("music.wav", Audio::MakeFlags(2, true), false, 10000);
    std::this_thread::sleep_for(std::chrono::seconds(4));
    Audio::StopAll();

    std::cout << "Stopping specific sound (channel 1)...\n";
    Audio::Stop(soundID1);

    std::cout << "Stopping all sounds\n";
    Audio::StopAll();

    Audio::Uninitialize();

    std::cout << "Finished\n";
    return 0;
}
*/